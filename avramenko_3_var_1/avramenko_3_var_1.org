#+TITLE: ООП: розробка сховища даних
#+AUTHOR: Авраменко Ігор Андрійович 201-Б
#+DATE: <2025-03-09 Sun>

* Аудиторна частина
** Приклади коду 16.1
Завдання «Збереження і обробка інформації про людей»
Створимо два класи:
1) Person – клас, який подає та обробляє інформацію про людей;
2) Manager – адаптована версія класу Person, що модифікує успадковану поведінку.

Попутно створимо екземпляри обох класів і протестуємо їх можливості.
Розглянемо приклад використання класів – збережемо екземпляри в
сховище у вигляді об'єктно-орієнтованої бази даних, який забезпечує
довгострокове їх зберігання. Завдяки цьому можна використовувати
програмний код прикладу як шаблон для створення своєї власної, повноцінної
бази даних.

*** Крок 1. Створення екземплярів.
Перше завдання – створити головний
клас Person. Назвемо файл person.py, класу дамо ім'я Person: class Person:
На етапі конструювання викликають метод конструктора __init__ для
ініціалізації новоствореного екземпляра. Передамо конструктору аргументи з
даними, які будуть зберігатися екземпляром, присвоїмо їх атрибутам аргументу
self, додамо ініціалізацію полів запису:
#+begin_src python :results output :exports both
  class Person:
      def __init__(self, name, job = None, pay = 0):
          # Конструктор має 3 аргументи
          self.name=name # заповнення поля під час створення
          self.job=job # self – нового екземпляру класу
          self.pay=pay

  bob = Person('Bob Smith') # Тестування класу
  sue = Person('Sue Jones', job='dev', pay=100000)
  # автоматично запустить __init__
  print(bob.name, bob.pay); print(sue.name, sue.pay)
  # атрибути в об‘єктах bob, sue різняться
#+end_src

#+RESULTS:
: Bob Smith 0
: Sue Jones 100000

Об'єкт =bob= отримує значення атрибутів =job=, =pay= за замовчуванням, а для
об'єкта =sue= значення всіх атрибутів вказують явно. Якщо запустити цей файл як
сценарій, програмний код в кінці файлу створить два екземпляри класу і
виведе значення двох атрибутів для кожного з них (=name=, =pay=):

#+begin_src python :results output :exports both
  import person

  print("Hello world!")
#+end_src

#+RESULTS:
: Bob Smith 0
: Sue Jones 100000
: Hello world!

Щоб тести виконувалися, тільки коли файл запускають як сценарій для
тестування, можна використати перевірку атрибуту =__name__= модуля.
Відповідні зміни в файлі наведено нижче:

#+begin_src python :results output :exports both :tangle person.py avramenko_3_aud_step_1_initialization.py
  class Person:
      def __init__(self, name, job=None, pay=0):
          self.name=name; self.job=job; self.pay=pay

  if __name__ == "__main__":
      # коли файл запускають для тестування
      bob = Person("Bob Smith")
      sue = Person("Sue Jones", job="dev", pay=100000)
      print(bob.name, bob.pay); print(sue.name, sue.pay)
      print("{0} {1}" .format(bob.name, bob.pay)) # метод format
      print("%s %s" %(bob.name, bob.pay)) # вираз форматування
#+end_src

#+RESULTS:
: Bob Smith 0
: Sue Jones 100000
: Bob Smith 0
: Bob Smith 0

#+begin_src python :results output :exports both
  import person

  ihor = person.Person("Ihor")

  print(type(ihor))
#+end_src

#+RESULTS:
: <class 'person.Person'>

Тепер при імпортуванні файлу person.py інтерпретатор створить новий
клас (але не буде використовувати його). Під час запуску файлу в якості
сценарію інтерпретатор створює два екземпляри класу і виводить значення
двох атрибутів для кожного з них (кожен екземпляр є незалежним простором
імен, тому їх атрибути можуть мати різні значення).

*** Крок 2. Додавання методів, які визначають поведінку об’єктів.
Клас =Person= виконує функції фабрики записів – він створює записи і заповнює їх
поля (атрибути екземплярів). Можна застосувати до таких записів деякі операції
над об'єктами. Хоча класи і додають додатковий структурний рівень, проте більшу
частину своєї роботи вони виконують за рахунок впровадження і обробки даних
базових типів, таких як списки і рядки (класи є лише невеликою структурної
надбудовою). Наприклад, поле =name= в наших об'єктах є звичайним рядком, тому ми в
змозі витягувати прізвища людей з наших об'єктів, розбиваючи значення атрибуту
прогалинами і використовуючи операцію індексування. Все це – операції над
базовими типами даних:
#+begin_src python :exports code :results none
  >>> name = "Bob Smith" # рядок
  >>> name.split() # витягування прізвища
  ['Bob', 'Smith']
  >>> name.split()[-1]
  # або [1], якщо ім'я завжди складається з 2 компонентів
  'Smith'
  Можна збільшити зарплату, змінивши значення поля pay:
  pay = 100000 # проста змінна
  pay *= 1.10 # збільшено на 10%, або pay=pay*1.10
  print(pay)
#+end_src

Щоб застосувати зазначені вище операції до об'єктів класу Person,
підставимо імена =bob.name= і =sue.pay= на місце =name= і =pay=. Операції залишаться
тими ж, але в якості об'єктів операцій будуть використані атрибути класу:

#+begin_src python :results output :exports both
  # Обробка вбудованих типів: рядки, зміна значення
  class Person:
      def __init__(self, name, job=None, pay=0):
          self.name = name; self.job = job; self.pay = pay

  if __name__ == "__main__":
      bob = Person("Bob Smith")
      sue = Person("Sue Jones", job='dev', pay=100000)
      print(bob.name, bob.pay); print(sue.name, sue.pay)
      print(bob.name.split()[-1]) # витягання прізвища
      sue.pay *=1.10 # підвищення зарплатні
      print(sue.pay)
#+end_src

#+RESULTS:
: Bob Smith 0
: Sue Jones 100000
: Smith
: 110000.00000000001

Тут додано в кінець три нових рядки, які витягують прізвище з об'єкта
bob, використовуючи операції над рядками і списками, і збільшують зарплату
sue, змінюючи значення атрибута pay за допомогою простої числової операції.
У певному сенсі об'єкт sue є змінним – він допускає зміну інформації про стан

Реалізуємо концепцію проектування, яку називають //інкапсуляцією//. Її ідея
полягає в тому, щоб заховати логіку операцій за інтерфейсами і тим самим
домогтися, щоб кожна операція мала одну реалізацію в програмі. Якщо в
подальшому буде необхідно внести зміни, модифікувати код доведеться тільки
в одному місці. Реалізуємо операції над об'єктами у вигляді методів класу, що
дозволяє застосовувати їх до будь-яких екземплярів класу. Перемістимо
реалізацію двох операцій з програми до методів класу, домігшись інкапсуляції.
Змінимо програмний код самоперевірки і замінимо в ньому запрограмовані
операції викликами методів:

#+begin_src python :results output :exports both :tangle avramenko_3_aud_encapsulation.py
    # Додано методи, які інкапсулюють операції
    class Person:
        def __init__(self, name, job=None, pay=0):
            self.name = name; self.job = job
            self.pay = pay

            # метод «виведення прізвища»
        def lastName(self): #методи, які реалізують поведінку екземплярів
            return self.name.split()[-1] # self – екземпляр

            # метод «зміна зарплати»
        def giveRaise(self, percent):
            self.pay=int(self.pay*(1+percent)) # внесення змін

    if __name__ == '__main__':
        bob = Person("Bob Smith")
        sue = Person("Sue Jones", job='dev', pay=100000)
        print(bob.name, bob.pay); print(sue.name, sue.pay)
        # використовують методи
        print(bob.lastName(),';', sue.lastName())
        sue.giveRaise(.10)
        #sue.pay *=1.10 # виконає те саме, що й попередній рядок
        print(sue.pay)
#+end_src

#+RESULTS:
: Bob Smith 0
: Sue Jones 100000
: Smith ; Jones
: 110000

Методи – це звичайні функції, які приєднують до класів, вони призначені
для обробки екземплярів цих класів. Метод lastName виконує над об'єктом self
операцію, яка раніше виконувалася над об'єктом bob (тут self – це об'єкт, який є
контекстом виклику методу). Метод lastName (є викликом функції) обчислює
значення, яке пізніше можна використати програмою, що його викликає.
Метод giveRaise виконує над об'єктом self операцію, яка раніше виконувалася
над об'єктом sue. Якщо запустити сценарій, він виведе результат:


Поле =pay= (заробітна плата) в об'єкті =sue= отримує цілочисельне значення
після його збільшення – всередині методу результат арифметичної операції
перетворений в ціле число за допомогою вбудованої функції =int=. Можна
реалізувати округлення до центів за допомогою вбудованої функції =round(N, 2)=,
використати тип =decimal= для забезпечення фіксованого точності або зберігати
грошові суми у вигляді дійсних чисел і відображати їх із застосуванням рядка
формату =% .2f або {0: .2f}=. У нашому прикладі ми відкидаємо центи за
допомогою функції =int=.

*** Крок 3. Перевантаження операторів
Можна задіяти можливість перевантаження операторів, – додавши в клас метод, який
виконує вбудовану операцію, коли її застосовують до екземплярів класу. Зокрема,
можна реалізувати метод перевантаження операторів =__str__=, який викликають, коли
екземпляр перетворюють в рядок для виведення. Оскільки цей метод використовують
для виведення даних про об'єкт, все, що ми отримаємо при виведенні об'єкта, є
значенням методу =__str__= цього об'єкта, який може бути визначений в класі
об'єкта або успадкований від суперкласу (методи, імена яких розпочинаються і
закінчуються двома символами підкреслення, успадковуються так само, як будь-які
інші). Додамо реалізацію цього методу в клас. Нижче наведено розширену версію
класу, яка виводить список атрибутів при відображенні екземплярів повністю:

#+begin_src python :results output :exports both :tangle avramenko_aud_step_3_operator_overloading.py
  # Додано метод __str__, який реалізує виведення об‘єктів повністю
  class Person:
      def __init__(self, name, job=None, pay=0):
          self.name=name; self.job=job; self.pay=pay

      def lastName(self):
          return self.name.split()[-1]

      def giveRaise(self, percent):
          self.pay = int(self.pay * (1 + percent))

      def __str__(self): # доданий метод
          return "[Person: %s, %s]" %(self.name, self.pay)
          # рядок для виведення
  if __name__ == "__main__":
      bob = Person("Bob Smith")
      sue = Person("Sue Jones", job="dev", pay=100000)
      print(bob); print(sue);
      print(bob.lastName(),';', sue.lastName())
      sue.giveRaise(.10); print(sue)
#+end_src

#+RESULTS:
: [Person: Bob Smith, 0]
: [Person: Sue Jones, 100000]
: Smith ; Jones
: [Person: Sue Jones, 110000]

Тут в методі =__str__= для створення рядка виводу застосувано оператор
форматування % (для реалізації необхідних дій класи можуть використати
вбудовані типи об'єктів і операції). Змінено код самоперевірки – він виводить
не окремі атрибути об'єктів, а об'єкт повністю. Якщо запустити цей
сценарій, отримаємо такий результат – функції print викликатимуть метод
=__str__=, який повертає рядки вигляду «[...]»:


*** Крок 4. Адаптація поведінки за допомогою підкласів
У класі =Person= задіяно більшість механізмів ООП, але не задіно адаптацію коду за
рахунок успадкування. Використано наслідування – екземпляри успадковують методи
свого класу. Тепер необхідно визначити відношення «суперклас/підклас», яке
дозволить трохи змінити успадковану поведінку. У цьому і полягає основна ідея
ООП – адаптація наявного коду дозволяє скоротити час, який витрачають на його
розробку.

**Створення підкласів** Застосуємо методологію ООП і адаптуємо клас =Person=,
розширивши ієрархію об'єктів. Для цього визначимо підклас =Manager=, який
успадковує клас =Person=. В підкласі =Manager= змінимо успадкований метод =giveRaise=
на більш вузькоспеціалізовану версією:

#+begin_src python
  class Manager(Person): # визначити підклас класу Person
#+end_src

Визначено клас з ім'ям =Manager=, який успадковує і може адаптувати
суперклас =Person= (клас =Manager= схожий на клас =Person=, але реалізує свій спосіб
збільшення зарплати). Нехай менеджер (екземпляр класу =Manager=) зазвичай
отримує не тільки надбавку (яка передається у вигляді відсотків), але й
додаткову премію (яка за замовчуванням становить =10%=). Наприклад, якщо
надбавка до зарплати менеджера становить =10%=, то реально зарплата буде
збільшена на =20%=. Новий метод розпочинається, як показано нижче. Згідно з
правилами, пошук в дереві успадкування закінчується, як тільки знайдено
перший метод з відповідним ім'ям. Необхідно виконати операцію =giveRaise= і
додати додаткову премію (викликати оригінал зі зміненими аргументами):


#+begin_src python :results none :exports both
  import person
  class Manager(person.Person): # Наслідує атрибути класу Person
      def giveRaise(self,percent,bonus=.10): #перевизначити для адапт-ї
          #Person.giveRaise(self,percent+bonus) #доповнює оригінал
          super.giveRaise(self,percent+bonus) #доповнює оригінал
#+end_src

Методи класу можна викликати на основі звернення до екземпляру або звернення до
класу. Виклик методу: =instance.method(args ...)= транслюється інтерпретатором в
еквівалентну форму: =class.method(instance, args ...)=, де клас, який містить
метод, що викликають, визначають відповідно до правил пошуку в дереві
спадкування, які діють і для методів. Нижче наведено код після виконання
останніх змін:

#+begin_src python :session :results output :exports both :tangle avramenko_3_aud_step_4_inheritance.py
  # Додано підклас, який адаптує поведінку суперкласу
  class Person:
      def __init__(self, name, job=None, pay=0):
          self.name = name; self.job = job; self.pay = pay
      def lastName(self):
          return self.name.split()[-1]
      def giveRaise(self, percent):
          self.pay = int(self.pay*(1+percent))
      def __str__(self):
          return "[Person: %s, %s]" % (self.name, self.pay)

  class Manager(Person):
      def giveRaise(self, percent, bonus=.10): # Перевизначення метода
          Person.giveRaise(self,percent+bonus) #Виклик м-ду з класу Person

  if __name__ == "__main__":
      bob = Person("Bob Smith")
      sue = Person("Sue Jones",job="dev",pay=100000)
      print(bob);print(sue);print(bob.lastName(),sue.lastName())
      sue.giveRaise(.10); print(sue)
      tom = Manager("Tom Jones", "mgr", 50000)
      # екземпляр Manager: __init__
      print(tom) # Виклик успадкованого __str__
      tom.giveRaise(.10) # Виклик адаптованої версії
      print(tom.lastName()) # Виклик успадкованого метода
      print(tom) # Виклик успадкованого __str__

      print("--All three--")
      for object in (bob, sue, tom):
          # Обробка об‘єктів узагальненим способом
          object.giveRaise(.10) #викличе метод giveRaise цього об‘єту
          print(object) #викличе метод __str__
#+end_src

#+RESULTS:
#+begin_example
[Person: Bob Smith, 0]
[Person: Sue Jones, 100000]
Smith Jones
[Person: Sue Jones, 110000]
[Person: Tom Jones, 50000]
Jones
[Person: Tom Jones, 60000]
--All three--
[Person: Bob Smith, 0]
[Person: Sue Jones, 121000]
[Person: Tom Jones, 72000]
#+end_example

Результати тестування за участю об'єктів =bob= і =sue= виглядають, як і раніше, а
коли для екземпляра =tom= класу =Manager= виконують підвищення зарплати на =10%=,
реальне підвищення становить =20%= (його зарплата збільшилася з =$50K= до =$60=), тому
що адаптовану версію методу =giveRaise= в класі =Manager= викличуть тільки для цього
об'єкта. При виведенні інформації про об'єкт tom використовують форматування,
визначене в методі =__str__= класу =Person=: екземпляри класу =Manager= успадковують
його, а також методи =lastName= і =__init__= від класу =Person=. Додамо в кінець коду
такий текст:

#+begin_src python :session :results output :exports both
  if __name__== "__main__":
      print("--All three--")
      for object in (bob, sue, tom):
          # Обробка об‘єктів узагальненим способом
          object.giveRaise(.10) #викличе метод giveRaise цього об‘єту
          print(object) #викличе метод __str__
#+end_src

Цей приклад демонструє «поліморфізм» в дії в Python – дія операції =giveRaise=
залежить від того, до якого об'єкту її застосовують. Враховуючи, що вибір версії
методу =giveRaise= грунтується на типі об'єкта, в результаті sue отримує надбавку
у =10%=, а =tom= – у =20%=. Нижче наведено результат роботи коду:


Тут змінна =object= може посилатися або на екземпляр класу =Person=, або на
екземпляр класу =Manager=, а інтерпретатор викличе відповідний метод =giveRaise=:

1) для об'єктів bob, sue буде викликана оригінальна версія методу з класу Person
2) для об'єкта tom – адаптована версія з класу Manager.

Якщо для класу =Manager= потрібно реалізувати щось інше, можна додати в клас
=Manager= унікальні методи, відсутні в класі =Person=. Нижче наведено фрагмент, в
якому метод =giveRaise= перевизначає метод суперкласу, адаптуючи його, а метод
=someThingElse= є новим доповненням до класу =Manager=):


#+begin_src python :results none
  class Person:
      def lastName(self): ...
      def giveRaise(self): ...
      def __str__(self): ...

  class Manager(Person): # Наслідування
      def giveRaise(self, ...): ... # Адаптація
      def someThingElse(self, ...): ... # Розширення

  tom = Manager()
  tom.lastName() # Успадкований метод
  tom.giveRaise() # Адаптована версія
  tom.someThingElse() # Додатковий метод
  print(tom) # Успадкований метод перевантаження
#+end_src

*** Крок 5. Адаптація конструкторів
Безглуздо вказувати значення ='mgr'=
(менеджер) в аргументі =job= (посада) при створенні об'єкта класу =Manager=: цю
посаду мають на увазі при назві класу. Краще заповнювати цей атрибут
автоматично, при створенні екземпляра класу Manager. Для цього можна
адаптувати роботу конструктора в класі Manager так, щоб він автоматично
підставляв назву посади.
Перевизначимо метод =__init__= в класі =Manager=, щоб він підставляв рядок
='mgr'= автоматично. Для цього будемо викликати метод =__init__= з класу Person за
рахунок звернення до імені класу, щоб ініціалізувати інші атрибути об'єкта. У
сценарію, який наведено нижче, створено новий конструктор для класу
=Manager= і змінено виклик, який створює об'єкт =tom= (ми не передаємо йому
назву посади ='mgr'=):


#+begin_src python :results output :exports both :tangle person.py avramenko_3_aud_step_5_polymorphism.py
  # Файл person.py - опис класів
  class Person:
      def __init__(self, name, job=None, pay=0):
          self.name=name
          self.job=job
          self.pay=float(pay)
      def lastName(self):
          #методи, які реалізують поведінку екземплярів
          return (self.name.split()[-1]) # self – екземпляр
      def giveRaise(self, percent):
          self.pay=int(self.pay*(1+percent)) # внесення змін
      def __str__(self):
          return ('%s, %s, %s' %(self.name,self.job, self.pay))
          # рядок для виведення

  class Manager(Person):
      def __init__(self,name,pay): # перевизначений конструктор
          Person.__init__(self,name,'mgr',pay)
          # Виклик конструктора зі значенням job=‗mgr‘
      def giveRaise(self, percent, bonus=.10):
          Person.giveRaise(self, percent+bonus)

  if __name__=='__main__': # файл запускають для тестування
      bob = Person('Bob Smith');
      sue=Person('Sue Jones', job='dev', pay=100000)
      print(bob); print(sue);
      print(bob.lastName(),';', sue.lastName())
      sue.giveRaise(.10) # використовують методи
      print(sue)
      tom = Manager('Tom Jones', 50000)
      tom.giveRaise(.10) # Виклик адаптованої версії
      print(tom.lastName()) # Виклик успадкованого метода
      print(tom) # Виклик успадкованого __str__
#+end_src

#+RESULTS:
: Bob Smith, None, 0.0
: Sue Jones, dev, 100000.0
: Smith ; Jones
: Sue Jones, dev, 110000
: Jones
: Tom Jones, mgr, 60000


Тут використано прийом розширення конструктора =__init__=, раніше застосований
для розширення методу =giveRaise= (виклик методу із суперкласу зі зверненням до
імені класу та явна передача екземпляру =self= ). Для ініціалізації атрибутів
екземпляру задіяно логіку конструктора класу =Person=. Таку форму виклику
конструктора суперкласу з конструктора підкласу використовують в Python.
Механізм успадкування, реалізований в інтерпретаторі, дозволяє відшукати тільки
один метод =__init__= на етапі конструювання – найнижчий в дереві класів. Якщо під
час конструювання об'єкта потрібно викликати метод =__init__=, розташований вище,
його необхідно викликати вручну, зверненням через ім'я суперкласу (можна явно
передати необхідні аргументи конструктору суперкласу або взагалі його не
викликати). Цей сценарій виводить такий результат:



*** Крок 6. Збереження об'єктів у сховищі (в базі даних)
Маємо систему з двох модулів, яка не тільки реалізує поставлене завдання подання
інформації про людей, а й надає узагальнений інструмент відображення атрибутів,
який в майбутньому можна використати і в інших програмах. Помістивши функції і
класи в модулі, ми забезпечили можливість багаторазового їх використання. А
організувавши програмне забезпечення у вигляді класів, ми забезпечили можливість
його розширення.

Об'єкти, створені за допомогою класів, не є справжніми записами
в БД: по завершенні програми всі створені екземпляри зникають – вони є
звичайними об'єктами в пам'яті комп'ютера і не зберігаються на пристроях
довготривалого зберігання (наприклад у файлах), тому їх не можна відновити при
наступному запуску програми. Можна організувати збереження об'єктів за допомогою
сховища об'єктів, яке дозволяє відновлювати об'єкти після того, як програма
створить їх і завершить роботу. Реалізуємо можливість збереження об'єктів.

Можливість збереження об'єктів у =Python= забезпечують три модуля в стандартній
бібліотеці: модуль =pickle= перетворює довільні об'єкти на =Python= в рядок байтів і
назад; =dbm= реалізує збереження рядків у файлах, які забезпечують можливість
звернення за ключем; =shelve= використовує перші два модуля, дозволяючи зберігати
об'єкти в файлах – сховищах, які забезпечують можливість звернення за ключем.
Модуль =pickle=: здатний перетворити будь-який об'єкт, який знаходиться в пам'яті,
в рядок байтів, який потім можна використати для відновлення оригінального
об'єкта.

Модуль =pickle= може обробляти майже всі створювані об'єкти (списки,
словники, вкладені комбінації з цих об'єктів, а також екземпляри класів).
Останнє особливо важливо, тому що ця можливість дозволяє зберігати дані
(атрибути) і поведінку (методи) – ця комбінація еквівалентна «записам» і
«програмам». Зберігаючи об'єкти в файлі у вигляді рядків за допомогою модуля
=pickle=, ви фактично забезпечуєте довготривале зберігання цих об'єктів: пізніше
досить завантажити ці рядки і відновити з них оригінальні об'єкти. За допомогою
модуля =pickle= достатньо організувати збереження об'єктів в простих файлах і
завантаження їх із файлів, однак модуль shelve забезпечує додаткові зручності,
дозволяючи зберігати об'єкти, оброблені модулем =pickle=, за ключем. Модуль =shelve=
перетворює об'єкт в рядок за допомогою модуля =pickle= і зберігає його під
зазначеним ключем у файлі =dbm=. Пізніше, коли це необхідно, модуль =shelve= витягує
рядок за ключем і відтворює оригінал об'єкту в пам'яті (за допомогою модуля
=pickle=). У програмі звернення до об'єктів в сховищі виглядає як звернення до
елементів словника: ви звертаєтеся до об'єкту за ключем, зберігаєте його,
виконуючи присвоєння за ключем, і можете використовувати інструменти словників
=(len, in, dict. keys)=, щоб отримати додаткову інформацію. Модуль =shelve=
відображає операції зі словником на об'єкти, які зберігаються у файлі. Єдина
відмінність між сховищами об'єктів і словниками полягає в тому, що сховища
необхідно попередньо відкривати, а потім закрити їх після внесення змін. Таким
чином, сховища можна розглядати, як найпростіші бази даних, які дозволяють
зберігати і витягувати об'єкти по ключу і тим самим забезпечують збереження
об'єктів між запусками програми. Сховища не підтримують можливість виконання
запитів, наприклад, на мові =SQL=, і відчувають нестачу додаткових можливостей,
якими володіють розвинуті БД (такі як обробка транзакцій), проте об'єкти, що
знаходяться в сховищі, здатні використовувати всю широту можливостей =Python=
після того, як вони будуть вилучені назад.

**** Модуль shelve. 6.1
Збереження об'єктів. Напишемо сценарій, який зберігає екземпляри класів у
сховищі – файл =makedb.py=. Це – новий файл, тому в нього необхідно імпортувати
класи, щоб з їх допомогою створити кілька екземплярів для подальшого збереження.
Раніше для завантаження класу в інтерактивну оболонку ми використовували
інструкцію =from=, але існує два способи завантаження класів з модулів, так само
як функцій та інших змінних:

1) завантажує клас за допомогою інструкції import
   #+begin_src python
     import person # завантажує клас за допомогою інструкції import
     bob = person.Person(...) # звернення до класу через ім‘я модуля
   #+end_src
2) завантажує клас за допомогою інструкції from
   #+begin_src python
     from person import Person
     bob=Person(...) # звернення до імені класу
   #+end_src


Для завантаження класів в сценарій використаємо інструкцію =from= (у
цьому випадку доведеться менше вводити з клавіатури). Скопіюйте фрагмент,
який створює екземпляри наших класів, в новий сценарій, щоб було що
зберігати. Створивши екземпляри, можна зберегти їх в сховищі. Для цього
достатньо імпортувати модуль =shelve=, відкрити нове сховище, вказавши ім'я
зовнішнього файлу, виконати присвоєння об'єктів за ключем і після завершення
закрити сховище:

#+begin_src python :results none :tangle makedb.py
  # Файл makedb.py: зберігає об‘єкти Person у сховищі
  from person import Person, Manager # імпортує класи
  bob = Person("Bob Smith") # створення об‘єктів для зберігання
  sue = Person("Sue Jones", job='dev', pay=100000)
  tom = Manager("Tom Jones", 50000)
  import shelve
  db = shelve.open("persondb") # ім‘я файлу у сховищі
  for object in (bob, sue, tom): # як ключ використати атрибут name
      db[object.name] = object # зберегти об‘єкт у сховищі
  db.close() # закрити після внесення змін
#+end_src



При присвоєнні об'єктів в якості ключів використовуються значення атрибутів
=name=. Ключами в сховище можуть бути будь-які рядки, які можна було б створити із
застосуванням унікальних характеристик, таких як ідентифікатор процесу і
значення часу (їх можна отримати за допомогою модулів =os= і =time= стандартної
бібліотеки). Одне обмеження – ключі можуть бути тільки рядками і повинні бути
унікальними, тому що під кожним ключем можна зберегти тільки один об'єкт (втім,
таким об'єктом може бути список або словник, що містить множину об'єктів). А ось
значеннями, які зберігаються по ключу, можуть бути об'єкти будь-якого типу: це
можуть бути об'єкти вбудованих типів, таких як рядки, списки, словники і
екземпляри класів користувача, а також вкладені комбінації з них. Якщо при
запуску сценарій нічого не виводить, це означає, що він добре працює – не
передбачено виведення інформації, тільки створення і зберігання об'єктів:

**** 6.2 Дослідження сховища в інтерактивному сеансі.
Маємо у поточному робочому каталозі один або більше файлів, імена яких
розпочинаються з =«persondb»=. Реально створювані файли можуть відрізнятися в
залежності від платформи, функція =shelve.open()= створює файли в поточному
робочому каталозі, якщо вказане ім'я файлу не містить повний шлях. Але незалежно
від того, де зберігаються ці файли, вони забезпечують доступ по ключу до подання
об'єктів, створених за допомогою модуля =pickle=. Не видаляйте ці файли – вони є
базою даних, яку доведеться копіювати або переміщувати, коли ви будете
створювати резервні копії вашого сховища або переносити його. Можна заглянути
всередину файлів сховищ за допомогою файлового менеджера (наприклад =Dolphin= на
=GNU/Linux=) або за допомогою інтерактивної оболонки =Python=, проте ці файли
мають двійковий формат і їх вміст не має великого сенсу поза модуль =shelve=.
Наша БД зберігається в трьох файлах (модуль =bsddb= є стороннім доповненням, яке
поширюють з відкритими вихідними текстами):

#+begin_src python :results none :exports both
  # Модуль, який дозволяє отримати список файлів у каталозі:
  # перевірка наявності файлів
  >>> import glob
  >>> glob.glob("person*")
  ["person.py","person.pyc","persondb.bak","persondb.dat","persondb.dir"]
  # Тип файлу: текстовий – для рядків, бінарний – для байтів
  >>> print(open("persondb.dir").read())
  "Tom Jones", (1024, 91)
  ...частину рядків опущено...
  >>> print(open("persondb.dat", "rb").read())
  b‘\x80\x03cperson\nPerson\nq\x00)\x81q\x01}q\x02(X\x03\x00\x00\x00
  payq\x03K...
  ...частину рядків опущено...
#+end_src

**** 6.2 **!!!ВІДХОДЖУ ВІД ПРИЛКЛАДУ ЛАБОРАТОНОЇ РОБОТИ!!!**
При запуску запропонованого коду отримую інший результат.
#+begin_src python
  ❯ python3
  Python 3.13.2 (main, Feb  5 2025, 08:05:21) [GCC 14.2.1 20250128] on linux
  Type "help", "copyright", "credits" or "license" for more information.
  >>> import glob
  >>> glob.glob('person*')
  ['persondb-wal', 'persondb-shm', 'persondb', 'person.py']
  >>> print(open('persondb.dir').read()
  ... )
  Traceback (most recent call last):
    File "<python-input-2>", line 1, in <module>
      print(open('persondb.dir').read()
            ~~~~^^^^^^^^^^^^^^^^
  FileNotFoundError: [Errno 2] No such file or directory: 'persondb.dir'
  >>> print(open('persondb').read())
  Traceback (most recent call last):
    File "<python-input-3>", line 1, in <module>
      print(open('persondb').read())
            ~~~~~~~~~~~~~~~~~~~~~^^
    File "<frozen codecs>", line 325, in decode
  UnicodeDecodeError: 'utf-8' codec can't decode byte 0x86 in position 98: invalid start byte
  >>> print(open('persondb-shm').read())
  Traceback (most recent call last):
    File "<python-input-4>", line 1, in <module>
      print(open('persondb-shm').read())
            ~~~~~~~~~~~~~~~~~~~~~~~~~^^
    File "<frozen codecs>", line 325, in decode
  UnicodeDecodeError: 'utf-8' codec can't decode byte 0xe2 in position 1: invalid continuation byte
#+end_src

**ЧИМ ЦЕ ВИКЛИКАНО?**
Різниця у файлах, що створюються, викликана тим, що на =Windows= =shelve=
використовує =dumbdbm= або =dbm= залежно від доступності, тоді як на =Linux= він
зазвичай використовує =dbm.gnu= або =dbm.ndbm=. У моєму випадку =shelve= створило
один файл =persondb= і додаткові =persondb-wal= та =persondb-shm=, що свідчить про
використання =SQLite= як бекенду.

- Використання =SQLite= як бекенду підтверджує відображення типу у файловому менеджері =Dolphin=:
  [[file:sqlite.png]]


Щоб перевірити вміст бази даних, замість відкриття =.dir= чи =.dat= я отримую
дані через shelve:
#+begin_src python
  >>> import shelve
  >>> db = shelve.open("persondb")
  >>> for key in db:
  ...     print(key,"=>",db[key])
  ... db.close()
  ...
  Bob Smith => Bob Smith, None, 0.0
  Sue Jones => Sue Jones, dev, 100000.0
  Tom Jones => Tom Jones, mgr, 50000.0
  >>>
#+end_src
Цей метод кросплатформений і правильно працюватиме незалежно від того, який
бекенд shelve використовує під капотом.

**** 6.2 Продовження
Щоб перевірити результат, напишемо ще один сценарій. Нижче наведено лістинг
інтерактивного сеансу, який виконує роль клієнта БД (файл =travaille.py=):
#+begin_src python
  >>> import shelve

  >>> db=shelve.open('persondb', 'r') # відкрити сховище
  >>> print(len(db)) # у сховищі маємо три ‗записи‘
  3
  >>> print(list(db.keys())) # keys – це заголовок
  ['Bob Smith', 'Sue Jones', 'Tom Jones']
  >>> bob=db['Bob Smith'] # витягти об‘єкт bob за ключем
  >>> print(bob) # викличе метод __str__
  Bob Smith, None, 0.0
  >>> print(bob.lastName()) # Викличе lastName з класу Person
  Smith
  >>> for key in db: # Ітерації, витягання, виведення
  ...     print(key, '=>', db[key])
  ...
  Bob Smith => Bob Smith, None, 0.0
  Sue Jones => Sue Jones, dev, 100000.0
  Tom Jones => Tom Jones, mgr, 50000.0
  >>> for key in sorted(db):
  ...     print(key,'=>',db[key]) #Ітерації через відсортований список ключів
  ...
  Bob Smith => Bob Smith, None, 0.0
  Sue Jones => Sue Jones, dev, 100000.0
  Tom Jones => Tom Jones, mgr, 50000.0
  >>>

#+end_src

Коли модуль pickle перетворює екземпляр класу, він записує атрибути екземпляру
self разом з ім'ям класу, з якого він був створений, та ім'ям модуля, де
знаходиться визначення цього класу. Коли пізніше об'єкт bob витягують зі
сховища, інтерпретатор імпортує клас і пов'язує з ним об'єкт bob. Завдяки цьому
після завантаження екземпляри класів автоматично знаходять поведінку свого
класу. Необхідно імпортувати класи, тільки якщо треба створювати нові
екземпляри, але не для роботи з існуючими.
**** 6.3 Оновлення об'єктів в сховищі
Створимо останній сценарій, який оновлює екземпляри (записи) при кожному
запуску, щоб переконатися, що об'єкти дійсно зберігаються (тобто при кожному
запуску програми доступні їх поточні значення). Файл =updatedb.py= виводить вміст
БД і збільшує зарплату одному з об'єктів при кожному запуску. Цей сценарій має
масу можливостей – при виведенні об'єктів автоматично викликають реалізацію
методу =__str__= і підвищення зарплати виконують викликом методу =giveRaise=:
#+begin_src python :results output :exports both :tangle updatedb.py
  import shelve
  db = shelve.open("persondb")
  # відкрити у сховищі файл з вказаним ім‘ям
  for key in sorted(db): # відобразити об‘єкти з БД
      print(key, "\t=>", db[key]) # Виведення в необхідному форматі

  sue=db["Sue Jones"] # витягти об‘єкти за ключем
  sue.giveRaise(.10) # змінити об‘єкт у пам‘яті шляхом виклику метода
  db["Sue Jones"]=sue # присвоїти за ключем,
  # щоб оновити об‘єкт у сховищі
  db.close() # закрити файл після внесення змін
#+end_src

Цей сценарій виводить вміст БД, тому його можна запустити кілька разів і
побачити, як змінюються об'єкти. Нижче наводено результати декількох запусків
сценарію (можна спостерігати, як підвищується зарплата =sue=):

#+RESULTS1:
: Bob Smith 	=> Bob Smith, None, 0.0
: Sue Jones 	=> Sue Jones, dev, 100000.0
: Tom Jones 	=> Tom Jones, mgr, 50000.0

#+RESULTS2:
: Bob Smith 	=> Bob Smith, None, 0.0
: Sue Jones 	=> Sue Jones, dev, 110000
: Tom Jones 	=> Tom Jones, mgr, 50000.0

#+RESULTS3:
: Bob Smith 	=> Bob Smith, None, 0.0
: Sue Jones 	=> Sue Jones, dev, 121000
: Tom Jones 	=> Tom Jones, mgr, 50000.0

Це – результат роботи модулів =shelve= і =pickle=, які входять до складу
=Python=, і поведінки, реалізуваної в класах. Можна перевірити результати
запуску сценарію за допомогою інтерактивної оболонки (еквівалент клієнта БД на
основі модуля =shelve=):
#+begin_src python
  >>> import shelve
  >>> db = shelve.open('persondb') # відкрити базу даних
  >>> rec = db['Sue Jones'] # витягти об'єкт за ключем
  >>> print(rec)
  Sue Jones, dev, 133100
  >>> rec.lastName()
  'Jones'
  >>> rec.pay
  133100
#+end_src

Реалізовано збереження об'єктів, створених з класів, в об'єктноорієнтованій БД
із застосуванням модуля =shelve= – простий у використанні системі, яка забезпечує
можливість збереження і вилучення об'єктів за ключем.

**** Модуль dbm
Повторимо пункти *6.1*, *6.2*, *6.3*, використовуючи модуль =dbm=.
#+begin_src python :results output :tangle makedb2.py
  # Файл makedb2.py: зберігає об‘єкти Person у сховищі
  import dbm

  from person import Person, Manager # імпортує класи
  bob=Person('Bob Smith') # створення об‘єктів для зберігання
  sue=Person('Sue Jones', job='dev', pay=100000)
  tom=Manager('Tom Jones', 50000)
  db = dbm.open('persondb','n') # ім‘я файлу у сховищі
  for object in (bob,sue,tom): # як ключ використати атрибут name
      print(object)
      db[object.name]=str(object) # зберегти об‘єкт у сховищі
  print(len(db))
  db.close() # закрити після внесення змін
#+end_src

#+RESULTS:
: Bob Smith, None, 0.0
: Sue Jones, dev, 100000.0
: Tom Jones, mgr, 50000.0
: 3

#+begin_src python :results output :tangle travaille.py
  # Файл travaille.py: робота з БД
  import dbm

  db=dbm.open('persondb', 'r') # відкрити сховище **ЗАМІНИВ 'n' (створити нову) на 'r' (читання)
  k=len(db) # у сховищі маємо три ‗рядки-записи‘
  print(list(db.keys())) # keys – це заголовок
  a=list(db.keys())
  while k>0: # звернення до записів БД
      f1=db[a[k-1]].decode()
      print(f1); k-=1
  print()
  for key in db: # Ітерації, витягання, виведення
      print(key, '=>', db[key])
  print()
  for key in sorted(db):
      print(key, '=>', db[key]) # Ітерації через відсортований
      # список ключів
  db.close() # закрити після внесення змін
#+end_src

#+RESULTS:
#+begin_example
[b'Bob Smith', b'Sue Jones', b'Tom Jones']
Tom Jones, mgr, 50000.0
Sue Jones, dev, 100000.0
Bob Smith, None, 0.0

b'Bob Smith' => b'Bob Smith, None, 0.0'
b'Sue Jones' => b'Sue Jones, dev, 100000.0'
b'Tom Jones' => b'Tom Jones, mgr, 50000.0'

b'Bob Smith' => b'Bob Smith, None, 0.0'
b'Sue Jones' => b'Sue Jones, dev, 100000.0'
b'Tom Jones' => b'Tom Jones, mgr, 50000.0'
#+end_example

#+begin_src python :results output :tangle updatedb.py
  # Файл updatedb.py: оновлює об‘єкт класу Person в БД
  import dbm
  from person import Person, Manager
  def Transform(a): #
      list=a.split(",")
      return list

  db=dbm.open('persondb', 'w') # відкрити сховище відкрити сховище **ЗАМІНИВ 'n' (створити нову) на 'w' (читання та запис)
  k=len(db) # у сховищі маємо три ‗записи‘
  print(list(db.keys())) # keys – це заголовок
  key=list(db.keys());

  # відкрити у сховищі запис файлу за вказаним ключем
  for i in sorted(key): # відобразити об‘єкти з БД
      print(i, '\t=>', db[i]) # Виведення в необхідному форматі
  print()
  while k>0: # звертаємося до записів БД
      if key[k-1]==b'Sue Jones':
          sue1 = db[b'Sue Jones'].decode() # витягти запис за ключем
          # f1=db[key[k-1]].decode()
          print(sue1);break
      k-=1

  l=Transform(sue1);
  ssue=Person(l[0], l[1], l[2])
  ssue.giveRaise(0.10) # змінити об‘єкт у пам‘яті шляхом виклику метода
  db[b'Sue Jones']=str(ssue) # присвоїти за ключем, щоб оновити сховище

  db.close() # закрити файл після внесення змін
#+end_src



#+RESULTS1:
: [b'Bob Smith', b'Sue Jones', b'Tom Jones']
: b'Bob Smith' 	=> b'Bob Smith, None, 0.0'
: b'Sue Jones' 	=> b'Sue Jones, dev, 100000.0'
: b'Tom Jones' 	=> b'Tom Jones, mgr, 50000.0'
:
: Sue Jones, dev, 100000.0

#+RESULTS2:
: [b'Bob Smith', b'Sue Jones', b'Tom Jones']
: b'Bob Smith' 	=> b'Bob Smith, None, 0.0'
: b'Sue Jones' 	=> b'Sue Jones,  dev, 110000'
: b'Tom Jones' 	=> b'Tom Jones, mgr, 50000.0'
:
: Sue Jones,  dev, 110000

#+RESULTS3:
: [b'Bob Smith', b'Sue Jones', b'Tom Jones']
: b'Bob Smith' 	=> b'Bob Smith, None, 0.0'
: b'Sue Jones' 	=> b'Sue Jones,   dev, 121000'
: b'Tom Jones' 	=> b'Tom Jones, mgr, 50000.0'
:
: Sue Jones,   dev, 121000

* Самостійна частина. Варіант 1
** Крок 1. Створити клас, який містить конструктор классу; на основі класу створити декілька об‘єктів.

#+begin_src python :results output :tangle avramenko_3_var_1_step_1.py
  class audytoriya():
      def __init__(self, nomer, purpose = None, sits = 0):
          self.nomer   = nomer
          self.purpose = purpose
          self.sits    = sits

  if __name__ == "__main__":
      audytoriya_0  = audytoriya(0)
      audytoriya_39 = audytoriya(39, "Лекційна",100)
      print(audytoriya_0.nomer, audytoriya_0.purpose, audytoriya_0.sits)
      print(audytoriya_39.nomer, audytoriya_39.purpose, audytoriya_39.sits)
#+end_src

#+RESULTS:
: 0 None 0
: 39 Лекційна 100

#+begin_src python :results output :exports both
  import avramenko_3_var_1_step_1
  print("hello world")
#+end_src

#+RESULTS:
: hello world

** Крок 2. Додати методи, які визначають поведінку об‘єктів.

#+begin_src python :results output :tangle avramenko_3_var_1_step_2.py
  class audytoriya():
      def __init__(self,nomer,purpose = None,sits = 0):
          self.setNomer(nomer), self.setPurpose(purpose), self.setSits(sits)

      def LessSits(self, deleted_sits):
          self.sits -= deleted_sits
      def MoreSits(self, added_sits):
          self.sits += added_sits

      #    GET
      def getNomer(self)  : return(self.nomer)
      def getPurpose(self): return(self.purpose if self.purpose != None else "не визначене")
      def getSits(self)   : return(self.sits    if self.sits    != 0    else "не визначена")

      #    SET
      def setNomer(self,nomer)    : self.nomer   = nomer
      def setPurpose(self,purpose): self.purpose = purpose
      def setSits(self,sits)      : self.sits    = sits

  if __name__ == "__main__":
      audytoriya_0  = audytoriya(0)
      audytoriya_39 = audytoriya(39, "Лекційна",100)
      print(audytoriya_0.getNomer(),  audytoriya_0.getPurpose(),  audytoriya_0.getSits())
      print(audytoriya_39.getNomer(), audytoriya_39.getPurpose(), audytoriya_39.getSits())
#+end_src

#+RESULTS:
: 0 не визначене не визначена
: 39 Лекційна 100

** Крок 3. Перевантаження операторів.

#+begin_src python :results output :tangle avramenko_3_var_1_step_3.py
  class audytoriya():
      def __init__(self,nomer,purpose = None,sits = 0):
          self.setNomer(nomer), self.setPurpose(purpose), self.setSits(sits)

      def LessSits(self, deleted_sits):
          self.sits -= deleted_sits
      def MoreSits(self, added_sits):
          self.sits += added_sits

      #    GET
      def getNomer(self)  : return(self.nomer)
      def getPurpose(self): return(self.purpose if self.purpose != None else "не визначене")
      def getSits(self)   : return(self.sits    if self.sits    != 0    else "не визначена")

      #    SET
      def setNomer(self,nomer)    : self.nomer   = nomer
      def setPurpose(self,purpose): self.purpose = purpose
      def setSits(self,sits)      : self.sits    = sits

      #    STR
      def __str__(self):
          return("""
          Аудиторія номер %d
          \tПризначення %s
          \tКількість стільців %s
          """%(self.nomer,self.getPurpose(),self.getSits()))

  if __name__ == "__main__":
     audytoriya_0  = audytoriya(0)
     audytoriya_39 = audytoriya(39, "Лекційна",100)
     print(audytoriya_0)
     print(audytoriya_39)
#+end_src

#+RESULTS:
#+begin_example

        Аудиторія номер 0
        	Призначення не визначене
        	Кількість стільців не визначена


        Аудиторія номер 39
        	Призначення Лекційна
        	Кількість стільців 100

#+end_example

** Крок 4. Адаптація поведінки за допомогою підкласів.
Визначити відношення «суперклас/підклас», додати підклас, який адаптує поведінку
суперкласу або/і містить унікальні методи, відсутні в суперкласі (один метод
перевизначає метод суперкласу, адаптуючи його, інший метод є новим доповненням
до підкласу).

#+begin_src python :results output :tangle avramenko_3_var_1_step_4.py
  import avramenko_3_var_1_step_3 as aud
  #    LEKCIYNA
  class Lekciyna    (aud.audytoriya):
      def setSits(self,sits, numer_of_tables = 1): self.sits = sits * numer_of_tables
  #    COMPUTERNA
  class Computerna (aud.audytoriya):
      def setSits(self,sits,with_computer = 0):
          super().setSits(sits)
          self.with_computer = with_computer
          if with_computer > sits:
              print("!к-сть місць з комп'ютером > загальної к-сті місць. Вірогідна помилка")
      def getSits(self):
          return ("%s, %s з яких обладнано комп'ютером" % (super().getSits(), self.with_computer))

  #    VYKLADATSKA
  class Vykladatska(aud.audytoriya):
      def setKafedra(self,kafedra): self.kafedra = kafedra
      def getKafedra(self): return(self.kafedra    if self.kafedra    != 0    else "не визначена")
      def __str__(self):
          return super().__str__() + "\tКафедра %s" % self.getKafedra()


  if __name__ == "__main__":
      print("""\nLEKCIYNA""")
      lekciyna_1 = Lekciyna(1)
      lekciyna_1.setSits(20,10)
      print(lekciyna_1.getSits())

      print("""\nCOMPUTERNA""")
      computerna_2 = Computerna(2)
      computerna_2.setSits(10, 18)
      print(computerna_2.getSits())

      print("""\nVYKLADATSKA""")
      vykladatska_3 = Vykladatska(3)
      vykladatska_3.setKafedra("Математичного Аналізу")
      print(vykladatska_3.getKafedra())
      print(vykladatska_3)
#+end_src

#+RESULTS:
#+begin_example

LEKCIYNA
200

COMPUTERNA
!к-сть місць з комп'ютером > загальної к-сті місць. Вірогідна помилка
10, 18 з яких обладнано комп'ютером

VYKLADATSKA
Математичного Аналізу

        Аудиторія номер 3
        	Призначення не визначене
        	Кількість стільців не визначена
        	Кафедра Математичного Аналізу
#+end_example

** Крок 5. Адаптація конструкторів (додати адаптований конструктор в підклас).

#+begin_src python :results output :tangle avramenko_3_var_1_step_5.py
  #    AUDYTORIYA
  class Audytoriya():
      def __init__(self,nomer,purpose = None,sits = 0):
          self.setNomer(nomer); self.setPurpose(purpose); self.setSits(sits)

      def LessSits(self, deleted_sits):
          self.sits -= deleted_sits
      def MoreSits(self, added_sits):
          self.sits += added_sits

      #    GET
      def getNomer(self)  : return(self.nomer)
      def getPurpose(self): return(self.purpose if self.purpose != None else "не визначене")
      def getSits(self)   : return(self.sits    if self.sits    != 0    else "не визначена")

      #    SET
      def setNomer(self,nomer)    : self.nomer   = nomer
      def setPurpose(self,purpose): self.purpose = purpose
      def setSits(self,sits)      : self.sits    = sits

      #    STR
      def __str__(self):
          return("""
          Аудиторія номер %d
          \tПризначення %s
          \tКількість стільців %s
          """%(self.nomer,self.getPurpose(),self.getSits()))



  #    LEKCIYNA
  class Lekciyna    (Audytoriya):
      #    __INIT__
      def __init__(self, nomer,sits):
          Audytoriya.__init__(self, nomer, "Лекційна", sits)
      #    ----
      def setSits(self,sits, numer_of_tables = 1): self.sits = sits * numer_of_tables



  #    COMPUTERNA
  class Computerna (Audytoriya):
      #    __INIT__
      def __init__(self, nomer,sits):
          Audytoriya.__init__(self, nomer, "Комп'ютерна", sits)
      #    ----
      def setSits(self,sits,with_computer = 0):
          super().setSits(sits)
          self.with_computer = with_computer
          if with_computer > sits:
              print("!к-сть місць з комп'ютером > загальної к-сті місць. Вірогідна помилка")
      def getSits(self):
          return ("%s, %s з яких обладнано комп'ютером" % (super().getSits(), self.with_computer))



  #    VYKLADATSKA
  class Vykladatska(Audytoriya):
      #    __INIT__
      def __init__(self, nomer,sits):
          Audytoriya.__init__(self, nomer, "Викладатська", sits)
          self.setKafedra(None)
      #    ----
      def setKafedra(self,kafedra): self.kafedra = kafedra
      def getKafedra(self): return(self.kafedra    if self.kafedra    != 0    else "не визначена")
      def __str__(self):
          return super().__str__() + "\tКафедра %s" % self.getKafedra()


  if __name__ == "__main__":
      print("""\nLEKCIYNA""")
      lekciyna_1 = Lekciyna(1, 10)
      print(lekciyna_1)

      print("""\nCOMPUTERNA""")
      computerna_2 = Computerna(2, 20)
      print(computerna_2)

      print("""\nVYKLADATSKA""")
      vykladatska_3 = Vykladatska(3, 30)
      print(vykladatska_3)
#+end_src

#+RESULTS:
#+begin_example

LEKCIYNA

        Аудиторія номер 1
        	Призначення Лекційна
        	Кількість стільців 10


COMPUTERNA

        Аудиторія номер 2
        	Призначення Комп'ютерна
        	Кількість стільців 20, 0 з яких обладнано комп'ютером


VYKLADATSKA

        Аудиторія номер 3
        	Призначення Викладатська
        	Кількість стільців 30
        	Кафедра None
#+end_example

** Крок 6. Збереження об'єктів в базі даних (модулі shelve і dbm). Дослідження сховища в інтерактивному сеансі.
*** Модуль shelve
#+begin_src python :results none :tangle avramenko_3_var_1_step_6_shelve.py
  from avramenko_3_var_1_step_5 import Audytoriya, Lekciyna, Computerna, Vykladatska
  #    LEKCIYNA
  lekciyna_301 = Lekciyna(301, 310)
  lekciyna_302 = Lekciyna(302, 320)
  lekciyna_303 = Lekciyna(303, 330)

  #    COMPUTERNA
  computerna_202 = Computerna(202, 220)
  computerna_207 = Computerna(207, 270)
  computerna_403 = Computerna(403, 430)

  #    VYKLADATSKA
  vykladatska_3 = Vykladatska(3, 30)
  import shelve
  db = shelve.open("MyDB_made_with_shelve")
  for object in (lekciyna_301,lekciyna_302,lekciyna_303,computerna_202,computerna_207,computerna_403,vykladatska_3):
      db[str(object.nomer)] = object
  db.close()
#+end_src

#+begin_src python :results output :tangle avramenko_3_var_1_step_6_shelve_explore.py
   import shelve
   db = shelve.open("MyDB_made_with_shelve")
   for key in db:
       print(key,"=>",db[key])
   db.close()
#+end_src

#+RESULTS:
#+begin_example
202 => 
        Аудиторія номер 202
        	Призначення Комп'ютерна
        	Кількість стільців 220, 0 з яких обладнано комп'ютером
        
207 => 
        Аудиторія номер 207
        	Призначення Комп'ютерна
        	Кількість стільців 270, 0 з яких обладнано комп'ютером
        
3 => 
        Аудиторія номер 3
        	Призначення Викладатська
        	Кількість стільців 30
        	Кафедра None
301 => 
        Аудиторія номер 301
        	Призначення Лекційна
        	Кількість стільців 310
        
302 => 
        Аудиторія номер 302
        	Призначення Лекційна
        	Кількість стільців 320
        
303 => 
        Аудиторія номер 303
        	Призначення Лекційна
        	Кількість стільців 330
        
403 => 
        Аудиторія номер 403
        	Призначення Комп'ютерна
        	Кількість стільців 430, 0 з яких обладнано комп'ютером
        
#+end_example

*** Модуль dbm
#+begin_src python :results none :exports both :tangle  avramenko_3_var_1_step_6_dbm.py
  import dbm

  from avramenko_3_var_1_step_5 import Audytoriya, Lekciyna, Computerna, Vykladatska
  #    LEKCIYNA
  lekciyna_301 = Lekciyna(301, 310)
  lekciyna_302 = Lekciyna(302, 320)
  lekciyna_303 = Lekciyna(303, 330)

  #    COMPUTERNA
  computerna_202 = Computerna(202, 220)
  computerna_207 = Computerna(207, 270)
  computerna_403 = Computerna(403, 430)

  #    VYKLADATSKA
  vykladatska_3 = Vykladatska(3, 30)

  db = dbm.open("MyDB_made_with_dbm", 'n')
  for object in (lekciyna_301,lekciyna_302,lekciyna_303,computerna_202,computerna_207,computerna_403,vykladatska_3):
      db[object.nomer]=str(object)
  db.close
#+end_src

#+begin_src python :results output :exports both :tangle avramenko_3_var_1_step_6_dbm_explore.py
  import dbm

  db = dbm.open("MyDB_made_with_dbm", 'r')
  print(list(db.keys()))
  db_keys = list(db.keys())
  # for i in db_keys:
  #     print(db[i])
  for i in db_keys:
      print(db[i].decode())
#+end_src

#+RESULTS:
#+begin_example
[b'202', b'207', b'3', b'301', b'302', b'303', b'403']

        Аудиторія номер 202
        	Призначення Комп'ютерна
        	Кількість стільців 220, 0 з яких обладнано комп'ютером
        

        Аудиторія номер 207
        	Призначення Комп'ютерна
        	Кількість стільців 270, 0 з яких обладнано комп'ютером
        

        Аудиторія номер 3
        	Призначення Викладатська
        	Кількість стільців 30
        	Кафедра None

        Аудиторія номер 301
        	Призначення Лекційна
        	Кількість стільців 310
        

        Аудиторія номер 302
        	Призначення Лекційна
        	Кількість стільців 320
        

        Аудиторія номер 303
        	Призначення Лекційна
        	Кількість стільців 330
        

        Аудиторія номер 403
        	Призначення Комп'ютерна
        	Кількість стільців 430, 0 з яких обладнано комп'ютером
        
#+end_example
